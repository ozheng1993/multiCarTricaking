#include <opencv2/core/utility.hpp>
#include <opencv2/tracking.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>
#include <time.h>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include <opencv2/video.hpp>
#include <opencv2/core/ocl.hpp>
#include "opencv2/opencv_modules.hpp"
#include "opencv2/core.hpp"
#include "opencv2/opencv.hpp"
#include "opencv2/video/background_segm.hpp"

//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
using namespace std;
using namespace cv;
// Global variables
Mat frameMat; //current frame mat
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat frOpen; //
Mat frClose; //
Mat frEroded; //
Mat frDil; //
Mat frBlur; //fg mask fg mask generated by MOG2 method
Mat frTh;
Mat outFrame;
Mat frame;
Mat frEdge;
Mat frKeypoints;
Mat frFinal;
Mat frFore;
Mat frBack;

int frameSkip=2;
int keyboard; //input from keyboard
Ptr<BackgroundSubtractorMOG2> pMOG2; //MOG2 Background subtractor


//static void refineSegments(const Mat& img, Mat& mask, Mat& dst)
//{
//    int niters = 3;
//    vector<vector<Point> > contours;
//    vector<Vec4i> hierarchy;
//    Mat temp;
//    dilate(mask, temp, Mat(), Point(-1,-1), niters);
//    erode(temp, temp, Mat(), Point(-1,-1), niters*2);
//    dilate(temp, temp, Mat(), Point(-1,-1), niters);
//    findContours( temp, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE );
//    dst = Mat::zeros(img.size(), CV_8UC3);
//    if( contours.size() == 0 )
//        return;
//    // iterate through all the top-level contours,
//    // draw each connected component with its own random color
//    int idx = 0, largestComp = 0;
//    double maxArea = 0;
//    for( ; idx >= 0; idx = hierarchy[idx][0] )
//    {
//        const vector<Point>& c = contours[idx];
//        double area = fabs(contourArea(Mat(c)));
//        if( area > maxArea )
//        {
//            maxArea = area;
//            largestComp = idx;
//        }
//    }
//    Scalar color( 0, 0, 255 );
//    drawContours( dst, contours, largestComp, color, FILLED, LINE_8, hierarchy );
//}


void processVideo(char* videoFilename);
int main( int argc, char** argv ){
    // show help
    if(argc<2){
        cout<<
        " Usage: tracker <video_name>\n"
        " examples:\n"
        " example_tracking_kcf Bolt/img/%04d.jpg\n"
        " example_tracking_kcf faceocc2.webm\n"
        << endl;
        return 0;
    }
    // declares all required variables
//  create the tracker
    MultiTracker trackers;
 
    //create GUI windows
    namedWindow("Frame");
    namedWindow("background");
    namedWindow("foreground");
    namedWindow("threshold");
   //MOG2 approach
    pMOG2 = createBackgroundSubtractorMOG2();
    pMOG2->setDetectShadows(true);
    pMOG2->setHistory(10);
    pMOG2->setNMixtures(3);
    pMOG2->setBackgroundRatio(100);
    pMOG2->setShadowThreshold(100);
    pMOG2->setShadowValue(0);
    // set input video
    std::string video = argv[1];
    VideoCapture cap(video);
//speed var
    vector<double> preX;
    vector<double> preY;
    vector<double> lastX;
    vector<double> lastY;
    vector<double> speed;
    vector<double> speedX;
    vector<double> speedY;
    vector<Rect> boundRect2(999);
    // container of the tracked objects
    vector<Rect2d> objects;
    std::vector<Ptr<Tracker> > algorithms;
    
    
    
    ///
    // //Setup SimpleBlobDetector parameters.
    SimpleBlobDetector::Params params;
    
    // Change thresholds
    params.minThreshold = 100;
    params.maxThreshold = 256;
    
    // Filter by Area.
    params.filterByArea = true;
    params.minArea = 300;
    
    // Filter by Circularity
    params.filterByCircularity = true;
    params.minCircularity = 0.1;
    
    // Filter by Convexity
    params.filterByConvexity = true;
    params.minConvexity = 0.87;
    
    // Filter by Inertia
    params.filterByInertia = true;
    params.minInertiaRatio = 0.01;
    
    
    // Storage for blobs
    vector<KeyPoint> keypoints;
    //
    int size=0;
    for(;;)
    {   cap>>frame;
        //get the frame number and write it on the current frame
        stringstream ss;
        stringstream fps;
        rectangle(frame, cv::Point(10, 2), cv::Point(450,20),
                  cv::Scalar(255,255,255), -1);
        ss << cap.get(CAP_PROP_POS_FRAMES);
        fps << cap.get(CAP_PROP_FPS);
        string frameNumberString = ss.str();
        string fpsNumberString = fps.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(255,0,0));
        putText(frame, fpsNumberString.c_str(), cv::Point(55, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(255,0,0));
        // stop the program if no more images
        if(frame.rows==0 || frame.cols==0)
        {
            break;
        }
        
        //car detection for first 60 frame
        
//        if(stoi(frameNumberString)<6000)
//        {
            string display1= "car detection init... car count: "+to_string(size);
            putText(frame, display1.c_str(), cv::Point(155, 15),FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(255,0,0));
            Rect Rec(400, 900, 3000, 780);
            rectangle(frame, Rec, Scalar(255), 10, 8, 0);
            //Select area described by REC and result write to the Roi
            Mat Roi = frame(Rec);
            resize(Roi, Roi, cv::Size(), 0.5, 0.5);
            //update the background model
            cvtColor(Roi, frameMat, CV_BGR2GRAY);
            pMOG2->apply(Roi, fgMaskMOG2,-1);
        //            //blur method
        Mat open =Mat::ones(Size(15,6),CV_8U);
        Mat close =Mat::ones(Size(16,6),CV_8U);
        erode(fgMaskMOG2,frEroded,cv::Mat(),cv::Point(-1,-1),2);
        
     //   dilate(frEroded,frClose,cv::Mat(),cv::Point(-1,-1),3);
        
        
        
//        morphologyEx( frEroded, frOpen, MORPH_OPEN, open );
        morphologyEx( frEroded, frDil, MORPH_DILATE, close );
        //        morphologyEx( frEroded, frOpen, MORPH_OPEN, open );
        morphologyEx( frDil, frClose, MORPH_CLOSE, open );
       // GaussianBlur( frClose, frBlur, Size( 5, 5 ), 0, 0 );
        
        
        
        
        
        
        
        
    
//        //            //blur method
//        Mat open =Mat::ones(Size(6,6),CV_8U);
//        Mat close =Mat::ones(Size(6,6),CV_8U);
//        morphologyEx( frTh, frOpen, MORPH_OPEN, open );
//        morphologyEx( frOpen, frClose, MORPH_DILATE, close );
        
            /// Apply the specified morphology operation 0= opening 1=closing
      
        
       
//            morphologyEx( frOpen, frClose, MORPH_CLOSE, open );
       //  morphologyEx( frOpen, frFinal, MORPH_DILATE, open );
       // imshow("back", frBack);
  
//            morphologyEx( frOpen, frClose, 1, close );
//            morphologyEx( frOpen, frClose, 3, close );
         Canny( frClose, frFinal, 200, 300, 3 );
        
    
//
        //for find contours
        vector<vector<Point> > contours;
        vector<Vec4i> hierarchy;
            /// Find contours
        findContours( frFinal, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE );

            /// Approximate contours to polygons + get bounding rects and circles
            vector<vector<Point> > contours_poly( contours.size() );
            vector<Rect> boundRect( contours.size() );
            vector<Point2f>center( contours.size() );
            vector<float>radius( contours.size() );
            for( int i = 0; i < contours.size(); i++ )
            {

                approxPolyDP( Mat(contours[i]), contours_poly[i], 3, true );
                boundRect[i] = boundingRect( Mat(contours_poly[i]) );
               // boundRect2[i] = boundingRect( Mat(contours_poly[i]) );
                minEnclosingCircle( (Mat)contours_poly[i], center[i], radius[i] );

            }
            /// Draw polygonal contour + bonding rects + circles
            Mat drawing = Mat::zeros( frClose.size(), CV_8UC3 );
            for( int i = 0; i< contours.size(); i++ )
            {
                if(contourArea(contours[i]) >200)
                {
                string carDinit = "car found : "+to_string(i);
                drawContours( Roi, contours_poly, i, Scalar(255,0,0), 1, 8, vector<Vec4i>(), 0, Point() );
                rectangle( Roi, boundRect[i].tl(), boundRect[i].br(),Scalar(255,0,0), 2, 8, 0 );
               // rectangle( frEdge, boundRect[i].tl(), boundRect[i].br(),Scalar(255,0,0), 2, 8, 0 );
                putText(Roi,carDinit, boundRect[i].tl(),FONT_HERSHEY_SIMPLEX,1 , cv::Scalar(255,0,0));
                    //putText(frEdge,carDinit, boundRect[i].tl(),FONT_HERSHEY_SIMPLEX,1.5 , cv::Scalar(255,0,0));

//                size=i;
//                boundRect2[i]=boundRect[i];
//                }
         }
        }
//        else if(stoi(frameNumberString)==60)
//        {
//            string display2= "car tracking init... car count: "+to_string(size);
//            putText(frame, display2.c_str(), cv::Point(155, 15),
//                    FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(255,0,0));
//            cout<<"<<<<<<<<<<start<<<<<<<<<<<<<<"<<endl;
//            for( int i = 0; i<size; i++ )
//            {
//                preX.push_back(0);
//                preY.push_back(0);
//                lastX.push_back(0);
//                lastY.push_back(0);
//                speed.push_back(0);
//                speedX.push_back(0);
//                speedY.push_back(0);
//                algorithms.push_back(TrackerKCF::create());
//                objects.push_back(boundRect2[i]);
//            }
//            trackers.add(algorithms,frame,objects);
//            cout<<"<<<<<<<<<<<<<<finsih<<<<<<<<<"<<endl;
//        }
//        else{
//            string display2= "car tracking started!! car count: "+to_string(size);
//            putText(frame, display2.c_str(), cv::Point(155, 15),
//                    FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(255,0,0));
//            trackers.update(frame);
//            // draw the tracked object
//            for(unsigned i=0;i<trackers.getObjects().size();i++)
//            {
//                rectangle( frame, trackers.getObjects()[i], Scalar( 0, 255, 0 ), 2, 1 );
//                preX[i]=trackers.getObjects()[i].x;
//                preY[i]=trackers.getObjects()[i].y;
//                speedX[i]=(preX[i]-lastX[i])*420/1980;
//                speedY[i]=(preY[i]-lastY[i])*420/1980;
//                speed[i]=sqrt(speedX[i]*speedX[i]+speedY[i]*speedY[i])*stoi(fpsNumberString)/frameSkip;
//                lastX[i]=preX[i];
//                lastY[i]=preY[i];
//                string location="car: "+to_string(i)+" | "+to_string(speed[i])+" m/s";
//                rectangle( frame, trackers.getObjects()[i], Scalar( 0, 255, 0 ), 2, 1 );
//                cv::putText(frame,
//                            location,
//                            cv::Point(trackers.getObjects()[i].x+10,trackers.getObjects()[i].y), // Coordinates
//                            cv::FONT_HERSHEY_COMPLEX_SMALL, // Font
//                            0.7, // Scale. 2.0 = 2x bigger
//                            cv::Scalar(255,0,0), // Color
//                            1); // Anti-alias // show image with the tracked object
//            }
        
//        }
        //update the tracking result
        
//        Rect WhereRec(0, 0, Roi.cols, Roi.rows);
//        // This copy Roi Image into loaded on position Where rec
//        Roi.copyTo(frame(WhereRec));
//        //resize window
       
//        resize(frTh, frTh, cv::Size(), 0.5, 0.5);
////        resize(frameMat, frameMat, cv::Size(),  0.15, 0.15);
//       resize(frEdge, frEdge, cv::Size(),  0.5, 0.5);
//     resize(fgMaskMOG2, fgMaskMOG2, cv::Size(), 0.5, 0.5);
//       resize(frOpen, frOpen, cv::Size(), 0.5, 0.5);
//        resize(frClose, frClose, cv::Size(),  0.5, 0.5);
//        resize(imgResult, imgResult, cv::Size(),  0.5, 0.5);
//        resize(frBlur, frBlur, cv::Size(), 0.3, 0.3);
//        // resize(frKeypoints, frKeypoints, cv::Size(), 0.5, 0.5);
////        //show the current frame and the fg masks
       imshow("Frame", Roi);
//////       // imshow("Framemat", frameMat);
//imshow("background", fgMaskMOG2);
//////          imshow("sharp", imgResult);
////imshow("threshold", frTh);
//         imshow("erded", frEroded);
////        imshow("open", frOpen);
// imshow("close", frClose);
//  imshow("final", frFinal);
//  imshow("blur", frBlur);
//        imshow("edge", frEdge);
//      imshow("keypoints", frKeypoints);
//////        //first line
////        moveWindow("open",0,250);
//        moveWindow("edge",0,500);
////        //second line
//        moveWindow("threshold",0,350);
//        moveWindow("background",550,350);
    //  moveWindow("close",0,500);
//
//        moveWindow("blur",0,700);
 // moveWindow("keypoints",0,750);
        
       
        //get the input from the keyboard
        keyboard = waitKey( 30 );
    }
    //delete capture object
    cap.release();
return 0;
}
