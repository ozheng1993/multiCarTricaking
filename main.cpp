//ou zheng
#include <opencv2/core/utility.hpp>
#include <opencv2/tracking.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>
#include <time.h>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include <opencv2/video.hpp>
#include <opencv2/core/ocl.hpp>
#include "opencv2/opencv_modules.hpp"
#include "opencv2/core.hpp"
#include "opencv2/opencv.hpp"
#include "opencv2/video/background_segm.hpp"
#include <math.h>       /* pow */
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
using namespace std;
using namespace cv;
// Global variables
Mat frameMat; //current frame mat
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat frOpen; //
Mat frClose; //
Mat frEroded; //
Mat frDil; //
Mat frBlur; //fg mask fg mask generated by MOG2 method
Mat frTh;
Mat outFrame;
Mat frame;
Mat frEdge;
Mat frKeypoints;
Mat frFinal;
Mat frFore;
Mat frBack;
Mat Roi;
bool startTrack;
int frameSkip=2;
int restartCounter=0;
int keyboard; //input from keyboard
Ptr<BackgroundSubtractorMOG2> pMOG2; //MOG2 Background subtractor
int newcarcounter=0;

//static void refineSegments(const Mat& img, Mat& mask, Mat& dst)
//{
//    int niters = 3;
//    vector<vector<Point> > contours;
//    vector<Vec4i> hierarchy;
//    Mat temp;
//    dilate(mask, temp, Mat(), Point(-1,-1), niters);
//    erode(temp, temp, Mat(), Point(-1,-1), niters*2);
//    dilate(temp, temp, Mat(), Point(-1,-1), niters);
//    findContours( temp, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE );
//    dst = Mat::zeros(img.size(), CV_8UC3);
//    if( contours.size() == 0 )
//        return;
//    // iterate through all the top-level contours,
//    // draw each connected component with its own random color
//    int idx = 0, largestComp = 0;
//    double maxArea = 0;
//    for( ; idx >= 0; idx = hierarchy[idx][0] )
//    {
//        const vector<Point>& c = contours[idx];
//        double area = fabs(contourArea(Mat(c)));
//        if( area > maxArea )
//        {
//            maxArea = area;
//            largestComp = idx;
//        }
//    }
//    Scalar color( 0, 0, 255 );
//    drawContours( dst, contours, largestComp, color, FILLED, LINE_8, hierarchy );
//}


void processVideo(char* videoFilename);
int main( int argc, char** argv ){
    // show help
    if(argc<2){
        cout<<
        " Usage: tracker <video_name>\n"
        " examples:\n"
        " example_tracking_kcf Bolt/img/%04d.jpg\n"
        " example_tracking_kcf faceocc2.webm\n"
        << endl;
        return 0;
    }
    // declares all required variables
//  create the tracker
    MultiTracker trackers;
 
    //create GUI windows
    namedWindow("Frame");
    namedWindow("background");
    namedWindow("foreground");
    namedWindow("threshold");
   //MOG2 approach
    pMOG2 = createBackgroundSubtractorMOG2();
    pMOG2->setDetectShadows(true);
    pMOG2->setHistory(100);
    pMOG2->setNMixtures(5);
    pMOG2->setBackgroundRatio(0.7);
    pMOG2->setShadowThreshold(120);
    pMOG2->setShadowValue(0);
    // set input video
    std::string video = argv[1];
    VideoCapture cap(video);
    //speed var
    vector<double> preX;
    vector<double> preY;
    vector<double> lastX;
    vector<double> lastY;
    vector<double> speed;
    vector<double> speedX;
    vector<double> speedY;
    vector<double> speedCounter;
    vector<double> speedPreAvg;
    vector<double> speedAvg;
    vector<Rect> boundRect2;
    // container of the tracked objects
    vector<Rect2d> objects;
    std::vector<Ptr<Tracker> > algorithms;
    
    // Storage for blobs
    vector<KeyPoint> keypoints;
    //
    int size=0;
    for(;;)
    {   cap>>frame;
        //get the frame number and write it on the current frame
        stringstream ss;
        stringstream fps;
        rectangle(frame, cv::Point(10, 2), cv::Point(450,20),
                  cv::Scalar(255,255,255), -1);
        ss << cap.get(CAP_PROP_POS_FRAMES);
        fps << cap.get(CAP_PROP_FPS);
        string frameNumberString = ss.str();
        string fpsNumberString = fps.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(255,0,0));
        putText(frame, fpsNumberString.c_str(), cv::Point(55, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(255,0,0));
        // stop the program if no more images
        if(frame.rows==0 || frame.cols==0)
        {
            break;
        }
        
        //car detection for first 60 frame
        
//        if(stoi(frameNumberString)<6000)
//        {
            string display1= "car detection init... car count: "+to_string(size);
            putText(frame, display1.c_str(), cv::Point(155, 15),FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(255,0,0));
           // Rect Rec(400, 900, 3000, 780);
           // rectangle(frame, Rec, Scalar(255), 10, 8, 0);
            //Select area described by REC and result write to the Roi
//            Mat Roi = frame(Rec);
        
        //Roi =frame;
            resize(frame, Roi, cv::Size(), 0.3,0.3);
            //update the background model
            cvtColor(Roi, frameMat, CV_BGR2GRAY);
            pMOG2->apply(Roi, fgMaskMOG2,-1);

        //blur method
        Mat open =Mat::ones(Size(8,8),CV_8U);
        Mat close =Mat::ones(Size(5,5),CV_8U);
        
        //morphologyEx( frEroded, frDil, MORPH_DILATE, close );
        //        morphologyEx( frEroded, frOpen, MORPH_OPEN, open );
        morphologyEx( fgMaskMOG2, frOpen, MORPH_OPEN, open );
        morphologyEx( frOpen, frClose, MORPH_CLOSE, close );
        //erode(fgMaskMOG2,frEroded,cv::Mat(),Point(-1, -1), 1.2);
        GaussianBlur( frClose, frBlur, Size(5, 5), 5, 5);
        
        //threshold(frBlur,frTh, 120,255.0, CV_THRESH_BINARY|THRESH_OTSU);
       
        if(stoi(frameNumberString)>60)
        {
            if(restartCounter>600)
            {
                startTrack=false;
            }
           
            //for find contours
            vector<vector<Point> > contours;
            vector<Vec4i> hierarchy;
            /// Find contours
            findContours( frBlur, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );
            /// Approximate contours to polygons + get bounding rects and circles
            vector<vector<Point> > contours_poly( contours.size() );
            vector<Rect> boundRect( contours.size() );
            vector<Point2f>center( contours.size() );
            vector<float>radius( contours.size() );
            for( int i = 0; i < contours.size(); i++ )
            {
                approxPolyDP( Mat(contours[i]), contours_poly[i], 3, true );
                boundRect[i] = boundingRect( Mat(contours_poly[i]) );
                boundRect[i].width+=20;
                boundRect[i].height+=20;
                boundRect[i].x-=10;
                boundRect[i].y-=10;
                // boundRect2[i] = boundingRect( Mat(contours_poly[i]) );
                minEnclosingCircle( (Mat)contours_poly[i], center[i], radius[i] );
            }
            /// Draw polygonal contour + bonding rects + circles
            Mat drawing = Mat::zeros( frClose.size(), CV_8UC3 );
            for( int i = 0; i< contours.size(); i++ )
            {
                // string carDinit = "CD init Dfor car: "+to_string(i);
                drawContours( Roi, contours_poly, i, Scalar(255,0,255), 0.5, 8, vector<Vec4i>(), 0, Point() );
                //rectangle( Roi, boundRect[i].tl(), boundRect[i].br(),Scalar(255,255,0), 0.5, 8, 0);
                //drawContours( frameCopy, contours_poly, i, Scalar(0,0,255), 1, 8, vector<Vec4i>(), 0, Point() );
                //rectangle( Roi, boundRect[i].tl(), boundRect[i].br(),Scalar(255,255,0), 0.5, 8, 0);
                //putText(frClose,carDinit, boundRect[i].tl(),FONT_HERSHEY_SIMPLEX, 0.25 , cv::Scalar(255,0,0));
                size=i;
                boundRect2.push_back(boundRect[i]);
                //rectangle( Roi, boundRect2[i].tl(), boundRect2[i].br(),Scalar(255,0,0), 0.5, 8, 0);
//                preX.push_back(0);
//                preY.push_back(0);
//                lastX.push_back(0);
//                lastY.push_back(0);
//                speed.push_back(0);
//                speedX.push_back(0);
//                speedY.push_back(0);
//                speedCounter.push_back(0);
//                speedAvg.push_back(0);
//                speedPreAvg.push_back(0);
                //cout<<"w:"<<boundRect[i].width<<"h:"<<boundRect[i].height<<endl;
            }
            if(startTrack==false)
            {
//                cout<<"start track"<<boundRect2.size()<<endl;
//                for( int i = 0; i< contours.size(); i++ )
//                {
//                    //cout<<"rect vilda: "<<i<<"x"<<boundRect2[i].x<<"y"<<boundRect2[i].y<<endl;
//
//                }
//
//
//                //                string display2= "car tracking init... car count: "+to_string(size);
//                //                putText(frame, display2.c_str(), cv::Point(155, 15),
//                //                        FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(255,0,0));
//                //                cout<<"<<<<<<<<<<start<<<<<<<<<<<<<<"<<endl;
                 //cout<<"object size brfore"<<trackers.getObjects().size()<<endl;
                for( int i = 0; i<boundRect2.size(); i++ )
                {
                    preX.push_back(0);
                    preY.push_back(0);
                    lastX.push_back(0);
                    lastY.push_back(0);
                    speed.push_back(0);
                    speedX.push_back(0);
                    speedY.push_back(0);
                    speedCounter.push_back(0);
                    speedAvg.push_back(0);
                    speedPreAvg.push_back(0);
                    algorithms.push_back(TrackerKCF::create());
                    objects.push_back(boundRect2[i]);
                   // cout<<"object "<<i<<"x"<<objects[i].x<<"y"<<objects[i].y<<endl;
                    //cout<<i<<endl;
                }
                
                
                trackers.add(algorithms,Roi,objects);
                
                
                
               // cout<<"object size after"<<trackers.getObjects().size()<<endl;
                
//                for(unsigned i=0;i<trackers.getObjects().size();i++)
//                {
//                    cout<<"taracker vilda "<<i<<"x"<<trackers.getObjects()[i].x<<"y"<<trackers.getObjects()[i].y<<endl;
//                }
                  startTrack=true;
            }
            
            if(boundRect2.size()>contours.size())
            {
                boundRect2.clear();
            }
            
            if(startTrack==true)
            {
                vector<Rect2d> objectsNew;
                vector<Ptr<Tracker> > algorithmsNew;
                vector<bool> newCar(boundRect2.size());
                //vector<double> dist(trackers.getObjects().size());
                for( int i = 0; i<boundRect2.size(); i++ )
                {
                    int temx= boundRect2[i].x;
                    int temy= boundRect2[i].y;
                    
                    newCar[i]=true;
                    for(int j=0;j<trackers.getObjects().size();j++)
                    {
                        int dist=0;
                        dist=sqrt ((trackers.getObjects()[j].x-temx)*(trackers.getObjects()[j].x-temx)+(trackers.getObjects()[j].y-temy)*(trackers.getObjects()[j].y-temy));
                        //cout<<"object: "<<i<<"tacker:"<<j<<"dist check "<<dist<<endl;
                        if(dist<30)
                        {
                            //cout<<"object: "<<i<<"tacker:"<<j<<"too close"<<endl;
                            newCar[i]=false;
                            
//                            preX.push_back(0);
//                            preY.push_back(0);
//                            lastX.push_back(0);
//                            lastY.push_back(0);
//                            speed.push_back(0);
//                            speedX.push_back(0);
//                            speedY.push_back(0);
//                            speedCounter.push_back(0);
//                            speedAvg.push_back(0);
//                            speedPreAvg.push_back(0);
//                            algorithms.push_back(TrackerKCF::create());
//                            objects.push_back(boundRect2[i]);
                        }
//                        else
//                        {
//                            cout<<"object: "<<i<<"tacker:"<<j<<"too close"<<endl;
//                        }
                    }
                    
                    if(newCar[i]==true)
                    {
                        cout<<"new car found: "<<i<<endl;
                        newcarcounter++;
                        rectangle( Roi, boundRect2[i], Scalar( 0, 255, 255 ), 0.5, 1 );
                        preX.push_back(0);
                                                    preY.push_back(0);
                                                    lastX.push_back(0);
                                                    lastY.push_back(0);
                                                    speed.push_back(0);
                                                    speedX.push_back(0);
                                                    speedY.push_back(0);
                                                    speedCounter.push_back(0);
                                                    speedAvg.push_back(0);
                                                    speedPreAvg.push_back(0);
                                                    algorithmsNew.push_back(TrackerKCF::create());
                                                    objectsNew.push_back(boundRect2[i]);
                        trackers.add(TrackerKCF::create(),Roi,boundRect2[i]);
                        
                    }
                   
                }
                cout<<"total added car"<<newcarcounter<<endl;
                //trackers.add(algorithmsNew,Roi,objectsNew);
                objectsNew.clear();
                algorithmsNew.clear();
                
               
            }
            
            
            //cout<<boundRect2.size()<<endl;
////               // cvtColor(frClose, frClose, CV_GRAY2RGB);
////
////
//////            }
////
////
////
////
//////            else if(startTrack==true)
//////            {
////                //restartCounter++;
////              //  cvtColor(frClose, frClose, CV_GRAY2RGB);
////
                    trackers.update(Roi);
////                // draw the tracked object
                for(int i=0;i<trackers.getObjects().size();i++)
                {
                    if(lastX[i]==0&&lastY[i]==0)
                    {
                       // cout<<"first time : "<<i<<endl;
                        lastX[i]=trackers.getObjects()[i].x;
                        lastY[i]=trackers.getObjects()[i].y;
                        speed[i]=0;
                    }
                    else
                    {


                        speedCounter[i]+=1;
                        preX[i]=trackers.getObjects()[i].x;
                        preY[i]=trackers.getObjects()[i].y;
                        speedX[i]=(preX[i]-lastX[i]);
                        speedY[i]=(preY[i]-lastY[i]);
                        lastX[i]=preX[i];
                        lastY[i]= preY[i];
                        speed[i]=(sqrt(speedX[i]*speedX[i]+speedY[i]*speedY[i]))/1980*220*stoi(fpsNumberString);
                        speedPreAvg[i]+=speed[i];
                        speedAvg[i]=speedPreAvg[i]/ speedCounter[i];
                    }
                    
                    if(speed[i]!=0)
                    {
                    
                        string location="X: "+to_string((int)lastX[i])+" Y: "+to_string((int)lastY[i]);
                        string speed="car:"+to_string(i)+"speed:"+to_string((int)speedAvg[i])+"m/s";
                        rectangle( Roi, trackers.getObjects()[i], Scalar( 0, 255, 0 ), 0.25, 1 );
                        cv::putText(Roi,speed,
                                    cv::Point(trackers.getObjects()[i].x+10,trackers.getObjects()[i].y-10), // Coordinates
                                    cv::FONT_HERSHEY_COMPLEX_SMALL, // Font
                                    0.5, // Scale. 2.0 = 2x bigger
                                    cv::Scalar(255,0,0), // Color
                                    1); // Anti-alias // show image with the tracked object

                        cv::putText(Roi,location,
                                    cv::Point(trackers.getObjects()[i].x+10,trackers.getObjects()[i].y), // Coordinates
                                    cv::FONT_HERSHEY_COMPLEX_SMALL, // Font
                                    0.5, // Scale. 2.0 = 2x bigger
                                    cv::Scalar(255,0,0), // Color
                                    1); // Anti-alias // show image with the tracked object
                    }
                    //rectangle( Roi, trackers.getObjects()[i], Scalar( 0, 255, 0 ), 0.25, 1 );
                    //cout<<"tracker: "<<i<<"x:"<<trackers.getObjects()[i].x<<i<<"y:"<<trackers.getObjects()[i].y<<endl;
                }

////
////                    for(unsigned j=0;j<trackers.getObjects().size();i++)
////                    {
////                        int x1=trackers.getObjects()[i].x;
////                        int y1=trackers.getObjects()[i].y;
////                        int x2=trackers.getObjects()[j].x;
////                        int y2=trackers.getObjects()[j].y;
////                        int dist=
////
////                    }
//
//
//

//                }
            }
//        }
        
        imshow("Frame", Roi);
//////       // imshow("Framemat", frameMat);
 //imshow("background", fgMaskMOG2);
//////          imshow("sharp", imgResult);
  // imshow("threshold", frTh);
//         imshow("erded", frEroded);
//  imshow("open", frOpen);
//  imshow("close", frClose);
//  imshow("final", frFinal);
//  imshow("blur", frBlur);
//        imshow("edge", frEdge);
//      imshow("keypoints", frKeypoints);
//////        //first line
////        moveWindow("open",0,250);
//        moveWindow("edge",0,500);
////        //second line
//        moveWindow("threshold",0,350);
//        moveWindow("background",550,350);
        moveWindow("close",0,500);
//
//        moveWindow("blur",0,700);
 // moveWindow("keypoints",0,750);
        
       
        //get the input from the keyboard
        keyboard = waitKey( 30 );
    }
    //delete capture object
    cap.release();
return 0;
}
